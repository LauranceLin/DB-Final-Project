import psycopg2
import psycopg2.extras
import bcrypt
import string
import random
import csv
import numpy as np
import datetime
from faker import Faker
from multiprocessing import Pool

fake = Faker()
USER_STATUS = ['active', 'banned']
USER_STATUS_PROB = [0.95, 0.05]
PASSWORD_LEN = range(8, 16)
PHONENUM_LEN = 10
USER_NAME_DICTIONARY = './csv/baby-names.csv'

ANIMAL_ORG_NAME_DICTIONARY = './csv/animal_org_names.csv'
VET_NAME_DICTIONARY = './csv/vet-names.csv'
FIRE_AGENCY_DICTIONARY = './csv/fireagency_names.csv'
POLICE_STATION_DICTIONARY = './csv/policeagency_names.csv'
SHORT_ADDRESS_DICTIONARY = './csv/short_address.csv'
RESPONDER_ADDRESS_DICTIONARY = './csv/responder_address.csv'
PLACEMENT_NAME_DICTIONARY = './csv/placement_names.csv'
PASSWORD_DICTIONARY_1 = './csv/bcrypt_password.csv'
PASSWORD_DICTIONARY_2 = './csv/bcrypt_password2.csv'

CITY = ['Taipei', 'New Taipei']
DISTRICTS = [
    [
        'Songshan', 'Xinyi', 'Daan', 'Zhongshan', 'Zhongzheng', 'Datong', 'Wanhua', 'Wenshan', 'Nangang', 'Neihu', 'Shilin', 'Beitou'
    ],
    [
        'Banqiao', 'Sanchong', 'Zhonghe', 'Yonghe', 'Xinzhuang', 'Xindian', 'Tucheng', 'Luzhou', 'Shulin', 'Xizhi', 'Yingge', 'Sanxia', 'Danshui', 'Ruifang', 'Wugu', 'Taishan', 'Linkou', 'Shenkeng', 'Shiding', 'Pinglin', 'Sanzhi', 'Shimen', 'Bali', 'Pingxi', 'Shuangxi', 'Gongliao', 'Jinshan', 'Wanli', 'Wulai'
    ]
]

DISTRICT_OFFICE_NAMES = [
    'Songshan District Office', 'Xinyi District Office', 'Daan District Office', 'Zhongshan District Office', 'Zhongzheng District Office', 'Datong District Office', 'Wanhua District Office', 'Wenshan District Office', 'Nangang District Office', 'Neihu District Office', 'Shilin District Office', 'Beitou District Office', 'Banqiao District Office', 'Sanchong District Office', 'Zhonghe District Office', 'Yonghe District Office', 'Xinzhuang District Office', 'Xindian District Office', 'Tucheng District Office', 'Luzhou District Office', 'Shulin District Office', 'Xizhi District Office', 'Yingge District Office', 'Sanxia District Office', 'Danshui District Office', 'Ruifang District Office', 'Wugu District Office', 'Taishan District Office', 'Linkou District Office', 'Shenkeng District Office', 'Shiding District Office', 'Pinglin District Office', 'Sanzhi District Office', 'Shimen District Office', 'Bali District Office', 'Pingxi District Office', 'Shuangxi District Office', 'Gongliao District Office', 'Jinshan District Office', 'Wanli District Office', 'Wulai District Office'
]

ANIMAL_TYPES = [
    'Dog', 'Cat', 'Bird', 'Snake', 'Deer', 'Monkey', 'Fish', 'Bear', 'Other'
]

EVENT_TYPES = [
    'Roadkill',
    'AnimalBlockingTraffic',
    'StrayAnimal',
    'AnimalAttack',
    'AnimalAbuse',
    'DangerousWildlifeSighting',
    'Other'
]

EVENT_STATUS = [
    "Ongoing", "Resolved", "Unresolved", "Deleted", "Failed", "False Alarm"
]

EVENT_STATUS_PROB = [0.1, 0.4, 0.1, 0.2, 0.15, 0.05]

# values generated by psql database after insertions
USER_ID_ARRAY = []
RESPONDER_ID_ARRAY = []
NUM_OF_CHANNELS = -1
EVENT_ID_ARRAY = []
PLACEMENT_ID_ARRAY = []
MAX_NUM_ANIMALS_PER_EVENT = 4

# user names
file = open(USER_NAME_DICTIONARY)
name_reader = csv.reader(file)
names = []
prob = []
sum = 0
for row in name_reader:
    if row[0] == 'year' and row[1] == 'name' and row[2] == 'percent' and row[3] == 'sex':
        continue
    names.append(row[1])
    prob.append(float(row[2]))
    sum += float(row[2])
prob = np.divide(prob, np.array(sum))


# responder names
f = open(ANIMAL_ORG_NAME_DICTIONARY)
f.readline()
reader = f.readlines()
ANIMAL_ORG_NAMES = [row.strip() for row in reader]
f.close()

f = open(VET_NAME_DICTIONARY)
f.readline()
reader = f.readlines()
VET_NAMES = [row.strip() for row in reader]
f.close()

f = open(FIRE_AGENCY_DICTIONARY)
f.readline()
reader = f.readlines()
FIRE_AGENCY_NAMES = [row.strip() for row in reader]
f.close()

f = open(POLICE_STATION_DICTIONARY)
f.readline()
reader = f.readlines()
POLICE_STATION_NAMES = [row.strip() for row in reader]
f.close()

f = open(SHORT_ADDRESS_DICTIONARY)
f.readline()
reader = f.readlines()
SHORT_ADDRESSES = [row.strip() for row in reader]
f.close()

f = open(RESPONDER_ADDRESS_DICTIONARY)
f.readline()
reader = f.readlines()
RESPONDER_ADDRESSES = [row.strip() for row in reader]
f.close()

f = open(PASSWORD_DICTIONARY_1)
f.readline()
reader = f.readlines()
BCRYPT_PASSWORDS = [row.strip() for row in reader]
f.close()

f = open(PASSWORD_DICTIONARY_2)
f.readline()
reader = f.readlines()
BCRYPT_PASSWORDS += [row.strip() for row in reader]
f.close()

RESPONDER_TYPES = [
    'Vet', 'Police', 'Fire Agency', 'Animal Protection Groups', 'District Office'
]

RESPONDER_NAMES = [
    VET_NAMES, POLICE_STATION_NAMES, FIRE_AGENCY_NAMES, ANIMAL_ORG_NAMES, DISTRICT_OFFICE_NAMES
]

f = open(PLACEMENT_NAME_DICTIONARY)
f.readline()
reader = f.readlines()
PLACEMENT_NAMES = [row.strip() for row in reader]
f.close()

# generate random values
def manual_gen_password():
    global PASSWORD_LEN
    len = random.choice(PASSWORD_LEN)
    letters = string.ascii_letters + string.digits
    passwd = ''.join(random.choice(letters) for _ in range(len))
    salt = bcrypt.gensalt()
    hashed = bcrypt.hashpw(passwd.encode(), salt).decode()
    return hashed

def gen_password():
    global BCRYPT_PASSWORDS
    return random.choice(BCRYPT_PASSWORDS)

def gen_phonenumber():
    global PHONENUM_LEN
    letters = string.digits
    return ''.join(random.choice(letters) for i in range(PHONENUM_LEN))

def gen_user_name():
    global names, prob
    name = np.random.choice(names, p=prob)
    return name

def gen_time_stamp(start = datetime.datetime(2013, 1, 1), end = datetime.datetime(2023, 11, 20)):
    global fake
    timestamp = fake.date_time_between(start_date=start, end_date=end)
    return timestamp

# gen email based on a given organization name
# truncated to 20 characters
def gen_org_email(org_name):
    email = org_name.lower().replace(" ", "_")[:20] + "@gmail.com"
    return email

# gen email based on a given user name
# truncated to 20 characters
def gen_user_email(user_name):
    random_digits = ''.join(random.choice(string.digits) for i in range(4))
    email = (user_name.lower() + random_digits)[:20] + "@gmail.com"
    return email

# gen users

def gen_user(i):
    global USER_STATUS, USER_STATUS_PROB
    name = gen_user_name()
    return (gen_password(), name, gen_user_email(name), gen_phonenumber(), np.random.choice(USER_STATUS, p=USER_STATUS_PROB))

def gen_all_users(cursor, num_of_users):
    global USER_ID_ARRAY
    global USER_STATUS, USER_STATUS_PROB
    insert_query = """INSERT INTO Users(password, name, email, phonenumber, status) VALUES %s;"""
    records = []

    with Pool(processes=16) as pool:
        records = pool.map(gen_user, range(num_of_users))

    print("About to insert all users")
    psycopg2.extras.execute_values(cursor, insert_query, records, template=None, page_size=100)
    print("Generated all users")


# gen responders
def gen_all_responders(cursor):
    global RESPONDER_NAMES, RESPONDER_TYPES, RESPONDER_ID_ARRAY
    insert_query = """INSERT INTO Responder(respondername, password, email, phonenumber, respondertype, address) VALUES %s;"""
    records = []
    for i in range(len(RESPONDER_TYPES)):
        type = RESPONDER_TYPES[i]
        org = RESPONDER_NAMES[i]
        for responder_name in org:
            records.append((responder_name, gen_password(), gen_org_email(responder_name), gen_phonenumber(), type, random.choice(RESPONDER_ADDRESSES)))
    print("About to insert all responders")
    psycopg2.extras.execute_values(cursor, insert_query, records, template=None, page_size=100)
    print("Generated all responders")


# user subscription records
def gen_user_sub(i):
    global USER_ID_ARRAY
    global NUM_OF_CHANNELS

    return (random.choice(range(NUM_OF_CHANNELS)), random.choice(USER_ID_ARRAY))

def gen_user_sub_records(cursor, num_of_records):
    global NUM_OF_CHANNELS
    assert(NUM_OF_CHANNELS > 0)
    insert_query = """INSERT INTO UserSubscriptionRecord(channelid, userid) VALUES %s;"""

    with Pool(processes=16) as pool:
        records = pool.map(gen_user_sub, range(num_of_records))

    records = list(set(records))
    psycopg2.extras.execute_values(cursor, insert_query, records, template=None, page_size=100)

    print("Generated user subscription records")

# user subscription records
def gen_respond_sub(i):
    global RESPONDER_ID_ARRAY
    global NUM_OF_CHANNELS
    return (random.choice(range(NUM_OF_CHANNELS)), random.choice(RESPONDER_ID_ARRAY))

def gen_responder_sub_records(cursor, num_of_records):
    global RESPONDER_ID_ARRAY
    global NUM_OF_CHANNELS
    assert(NUM_OF_CHANNELS > 0)
    insert_query = """INSERT INTO ResponderSubscriptionRecord(channelid, responderid) VALUES %s"""

    with Pool(processes=16) as pool:
        records = pool.map(gen_respond_sub, range(num_of_records))

    records = list(set(records))

    psycopg2.extras.execute_values(cursor, insert_query, records, template=None, page_size=100)
    print("Generated responder subscription records")

# gen channels
def gen_all_channels(cursor):
    global NUM_OF_CHANNELS
    insert_query = """INSERT INTO Channel(channelid, eventdistrict, eventtype, eventanimal) VALUES %s;"""
    idx = 0
    records = []
    for dist in ([None] + DISTRICTS[0] + DISTRICTS[1]):
        for eventtype in ([None] + EVENT_TYPES):
            for animal in ([None] + ANIMAL_TYPES):
                records.append((idx, dist, eventtype, animal))
                idx += 1
    NUM_OF_CHANNELS = idx
    psycopg2.extras.execute_values(cursor, insert_query, records, template=None, page_size=100)

    print("Channels inserted successfully into channel table")

def gen_all_placements(cursor):
    global PLACEMENT_NAMES
    global SHORT_ADDRESSES
    idx = 0
    records = []
    insert_query = """INSERT INTO Placement(placementid, name, address, phonenumber) VALUES %s;"""
    for name in PLACEMENT_NAMES:
        records.append((idx, name, random.choice(SHORT_ADDRESSES), gen_phonenumber()))
        idx += 1
    psycopg2.extras.execute_values(cursor, insert_query, records, template=None, page_size=100)

    print("Generated all placements")

# gen events
def gen_event(i):
    global CITY, DISTRICTS, SHORT_ADDRESSES, EVENT_STATUS, EVENT_STATUS_PROB, RESPONDER_ID_ARRAY, USER_ID_ARRAY

    cityindex = random.choice(range(len(CITY)))
    status = np.random.choice(EVENT_STATUS, p=EVENT_STATUS_PROB)
    random.choice(RESPONDER_ID_ARRAY)

    if(status == EVENT_STATUS[2] or status == EVENT_STATUS[3]):
        responder = None
    else:
        responder = random.choice(RESPONDER_ID_ARRAY)

    return (
        random.choice(EVENT_TYPES),
        random.choice(USER_ID_ARRAY),
        responder,
        status,
        "this is a short description",
        CITY[cityindex],
        random.choice(DISTRICTS[cityindex]),
        random.choice(SHORT_ADDRESSES),
        gen_time_stamp())

def gen_events(cursor, num_of_events):
    global CITY, DISTRICTS
    insert_query = """INSERT INTO Event(eventtype, userid, responderid, status, shortdescription, city, district, shortaddress, createdat) VALUES %s;"""

    # "Ongoing", "Resolved", "Unresolved", "Deleted", "Failed", "False Alarm"
    records = []
    with Pool(processes=16) as pool:
        records = pool.map(gen_event, range(num_of_events))

    psycopg2.extras.execute_values(cursor, insert_query, records, template=None, page_size=100)

def get_all_userids(cursor):
    global USER_ID_ARRAY
    select_query = "SELECT userid FROM Users;"
    cursor.execute(select_query)
    userids = cursor.fetchall()
    USER_ID_ARRAY = [row[0] for row in userids]

def get_all_responderids(cursor):
    global RESPONDER_ID_ARRAY
    select_query = "SELECT responderid FROM Responder;"
    cursor.execute(select_query)
    responderids = cursor.fetchall()
    RESPONDER_ID_ARRAY = [row[0] for row in responderids]

def get_num_of_channels(cursor):
    global NUM_OF_CHANNELS
    select_query = "SELECT COUNT(*) FROM Channel;"
    cursor.execute(select_query)
    NUM_OF_CHANNELS = cursor.fetchone()[0]

def get_event_ids(cursor):
    global EVENT_ID_ARRAY
    select_query = "SELECT eventid FROM Event;"
    cursor.execute(select_query)
    eventids = cursor.fetchall()
    EVENT_ID_ARRAY = [row[0] for row in eventids]

def get_placement_ids(cursor):
    global PLACEMENT_ID_ARRAY
    select_query = "SELECT placementid FROM placement;"
    cursor.execute(select_query)
    placementids = cursor.fetchall()
    PLACEMENT_ID_ARRAY = [row[0] for row in placementids]

def gen_event_animals(cursor):
    global MAX_NUM_ANIMALS_PER_EVENT
    insert_query = """INSERT INTO Animal(EventId, Type, Description, PlacementId) VALUES %s;"""
    records = []
    num_animals = random.randint(1, MAX_NUM_ANIMALS_PER_EVENT)
    for eid in EVENT_ID_ARRAY:
        for _ in range(num_animals):
            records.append((eid, random.choice(ANIMAL_TYPES), "This is a description", random.choice(PLACEMENT_ID_ARRAY)))
    psycopg2.extras.execute_values(cursor, insert_query, records, template=None, page_size=100)

    print("Generated all animals")

conn = psycopg2.connect(
    host="127.0.0.1",
    port="5432",
    user="postgres",
    password="postgres",
    database="furalert"
)

cursor = conn.cursor()

# generate all channels
gen_all_channels(cursor)
get_num_of_channels(cursor)
conn.commit()

# generate users
gen_all_users(cursor, 500000)
get_all_userids(cursor)
conn.commit()

# generate responders
gen_all_responders(cursor)
get_all_responderids(cursor)
conn.commit()

# generate events
gen_events(cursor, 500000)
get_event_ids(cursor)
conn.commit()

# generate user subscription records
gen_user_sub_records(cursor, 500000)
conn.commit()

# generate responder subscription records
gen_responder_sub_records(cursor, 500000)
conn.commit()

# generate placements
gen_all_placements(cursor)
get_placement_ids(cursor)
conn.commit()

# generate event animals
gen_event_animals(cursor)
conn.commit()

conn.close()
